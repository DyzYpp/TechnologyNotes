#### 1. 数据库表哪些情况需要建立索引

- 主键自动建立唯一索引

- 频繁作为查询条件的字段应创建索引

- 查询中与其它表关联的字段，外键关系建立索引

- 频繁更新的字段不适合建立索引

- where条件里用不到的字段不建立索引

- 单键/组合索引的选择问题，(高并发下倾向创建组合索引)

- 查询中排序的字段，排序字段若通过索引去访问将大大提高排序效率

- 查询中统计或分组的字段

  ------

  

#### 2. 数据库表哪些情况不需要建立索引

- 表数据少

- 频繁增删改的表

- 数据重复且分布平均的表字段

  ------

  

#### 3. Explain

##### 3.1 id  表的读取顺序

- id相同 从上到下顺序执行
- 如果是子查询，id不同，按id从大到小的顺序执行
- id相同又不同，id值越大，优先级越高，越先执行，id相同的，可以认为是一组，从上往下顺序执行。

##### 3.2 select_type 数据读取操作的操作类型

- simple       简单的select查询，查询中不包含子查询或union
- primary     查询中包含任何复杂的子部分，最外层查询被标记为
- subquery   在select或where列表中包含子查询
- derived       在from列表中包含的子查询被标记为deriver(衍生)，mysql会递归执行这些子查询把结果放在临时表里。
- union          若第二个select出现在union之后，则被标记为union;若union包含在from子句的子查询中，外层select被标记为: derived
- union result    从union表获取结果的select

##### 3.3 table 表

显示这一行数据是关于哪张表的

##### 3.4 type 性能级别

1. system	表只有一行记录(相当于系统表)，是const类型的特例，平时不会出现，可以忽略不计

2. const       表示通过索引，一次就找到了，const用于比较parmary_key和unique索引，因为只匹配一行数据，所以很快，如将主键置于where列表中，mysql就能将该查询转换为一个常量。

3. eq_ref      唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描

4. ref            非唯一性索引扫描，返回匹配某个单独值的所有行

5. range       检索给定范围的行

6. index        全索引扫描

7. all              全表扫描，性能最差。

   **一般来说，sql查询效率至少到range级别。**

##### 3.5 possible_keys 哪些索引可以使用

查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

##### 3.6 key  哪些索引实际被使用

实际使用的索引，如果为null，则没有使用到索引

查询中若使用了覆盖索引，则该索引只出现在key中

##### 3.7 key_length

表示索引使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精度的情况下，长度越短越好，key_length显示的值是索引字段的最大可能长度，并并非实际长度，即key_length是根据表定义而得，不是通过表内检索出的。

##### 3.8 ref 表之间的引用

表示索引的具体信息，哪个库的哪张表的哪个字段。

##### 3.9 rows 每张表都多少行被优化器查询

##### 3.10 Extra 包含不适合在其他列显示，但十分重要的信息

1. 